Homework 1
----------

### By James Hicks

1.  The four components of the software crisis are, the software being
    completed over budget, the software being completed later than
    scheduled, the software missing features, and the software getting
    cancelled.

2.  The difference between software development cycles and software life
    cycles are that the development cycle covers the softwares entire
    development from the second that it became an idea to the
    implementation of that idea. Whereas the softwares life cycle goes
    even further beyond that to the softwares death.

3.  For perfective maintenance a good example would be updating the
    mechanics or features of a video game. For instance a developer may
    determine that a way to improve the loot system of the game would be
    to add a loot all button so that the player doesn't have to
    individually select each piece of loot that pops up on the screen.
    An example of adaptive maintenance being used for video games would
    be when a new piece of hardware comes out that if utilized could
    improve your game. This could range from giving the game VR support
    to implementing newer graphics cards to improve the visual quality
    of the game.

4.  Unlike software, hardware starts to become obsolete or begins to
    degrade due to age which results in having to get a new piece of
    hardware since you can't update that particular piece of hardware
    you were using. Whereas with software you can update it without
    having to replace it with a better version of itself. Instead you
    can just add new features to make it be able to do what you want it
    to do.

5.  It shows that the earlier that you can catch the fault the easier it
    will be to fix it, since you don't have to worry about that fixing
    new faults that could result from fixing that fault. It also shows
    that software engineers focus on trying to find these faults as
    early as possible in the hopes of avoiding the higher cost of
    finding the faults late in the development cycle or after
    implementation.

6.  The reason that these phase are not seperated is due to the fact
    that there implementation as phases is adaptable. For instance with
    the documentation phase, the documentation of the project must
    always be up to date meaning that this "phase" is going on all the
    time during development. This is also true for the testing and
    planning phases. You always want to be testing the software because
    you would like to catch any faults as early as possible. The
    planning phase can also change at anytime during the development of
    the software, sometimes you have to change it due to the demands of
    the users/clients and sometimes you have to change them because your
    prior plan just isn't going to work.

7.  This statement can be considered true due to the fact that object
    oriented techniques tend to involve both operation oriented and
    attribute oriented data. These two types of data are used in
    classical progamming techniques although unlike object oriented
    techniques the classical style cannot use both.

8.  The reason that it is so important to interact with the
    clients/users of the software is so that you can build the software
    to what they want. You wouldn't want to spend a long time developing
    the software to find out that the clients/users wanted something to
    be entirely different because that would make all of the time that
    you spent developing the software a waste of time. By constantly
    interacting with the clients/users you can avoid this issue.

9.  One of the ways that I improve my skill in my particular field of
    studies (video game development), is that whenever I think of a type
    of game that has mechanics that I have not tried implementing. I
    usely think of a way that I could implement them and in some cases
    create a basic version of those mechanics in Unity(game development
    software). This helps me improve my game developing skills by giving
    me practice on developing the code needed to implement these
    mechanics.

10. This essay discusses the author's thoughts and experience that led
    to him creating the Cathedral and Bazaar method of developing code.
    It did a good job of discussing how beneficial releasing your code
    to the public could be for the improvement of your code. It also did
    a good job of giving advice to the reader on how to improve
    themselves as a software developer. It gave some of the more obvious
    advice, such as reuse code when you can. But it also had some advice
    that I haven't thought about before, such as the benefits of
    treating your beta testers as valuable resources so that in return
    they will become a valuable resource. Overall I thought that the
    essay provided some useful information that I hadn't thought about
    before and reinforced some of the advice that I have been given
    before.


