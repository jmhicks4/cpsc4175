## Homework 5
### By James Hicks
1. Object-oriented design and data-oriented design. With object-oriented design you focus on the operations of the software, whereas with data-oriented design you focus on the data side of your software.

2. The input is the point of highest abstraction of input, where the input becomes internal data that is operated on by the product. The output is the point of highest abstraction of output, where the data flow is similiar to the first point in the flow of data. By using both of these methods you can sort the data flow allowing you to create a program with great cohesion.

3. The variables that would be required for this project would be, the necessary classes for their major, the classes they have taken, the credit hours completed, and the grades that they have gotten in those classes.

4. The first step in this program would be to determine if they have completed enough credit hours to complete the major, because if they haven't it doesn't matter which courses they have taken and their grades. After that it will need to see if they have completed the required courses by comparing the required course to the classes taken. Followed by finding out if they got high enough grades for those courses to complete the major.

5. The courses class, where it will contain a list of the courses you have completed, how many credit hours they are worth, and if you passed them or not. This class would contain a method where you can determine how many credit hours you have completed by finding out if you have passed a class and how many credit hours you will get. It would determine if you completed all of the required courses by looking through a list of the classes you have completed and comparing them to another list that contains the required courses for that major. It would also contain a method that could compare the answers from both of the previous methods and tells the user whether they passed or not.

6. The development of our project can best be described as iterative. This is due to the fact that our project has constantly benefited from using an iterative process. Due to the fact that we have had multiple analysis phases we have been able to constantly improve our original ideas for the project. This is due to the ability to start an implementation and then think about what could improve that current implementation or what could compliment it. With the iterative process we have been able to improve our project with each step.

7. Testing a design is somewhat limiting due to the fact that things can change after the implementation stage that would leave your design test out of date. In order to test the graduation program I would first check to make sure that the classes list were printing the correct data, since if it isn't we won't get accurate results from any of our other methods. Then I would check both of the methods that determine if we have the correct amount of credit hours and the mandatory courses completed. I would check with various scenarios in which it should pass and shouldn't pass. After that I would check the method that would make sure we pass both of those methods. If that method works properly that should be all the testing needed for that part of the project.

8. The answer would be 11 - 10 + 2 = 3. This is due to the fact that there are 11 connecting paths and 10 nodes, which led me to the numbers to input into the cyclomatic complexity equation.

9. One CASE tool i have used before is a tool called Modelio. To be honest I was not a huge fan of using it, while I was able to get the program that I wanted finish running, I believe that I could have finished it a lot quicker just programming it. That might change if I were to practice with the tool more, which for the moment doesn't make much sense since we don't use it in school a lot.

10. The article that we read described the programmers at NASA, how they make and design their code to be as close to perfect as possible. First off, I find it amazing that a group of over 200 people are able to make a program complicated enough to run a shuttle but bug free enough to where it won't crash or cause any life threatening issues to the crew. At first this seemed impossible to me until they describe their work culture. At the NASA programming lab they focus on a culture of sticking to the plan. At first I thought that at such high and prestigious lab that they would focus on getting the best of the best that could introduce programming concepts that would bring their code to levels beyond what was thought possible but they explained the reason why they wouldn't do that. Ambition would lead to programmers trying to improve the code in their own way which would make it near impossible to code a program that would be as bug free as NASA needs it to be. The lack of ambition makes them be able to stick to their original plan, which allows them to create such bug free code. It also explains that they spend quite a bit of the initial creation phase not coding but planning, so that they can have a perfected plan to avoid as many issues as possible. Overall this article showed how NASA is able to make such bug free software by sticking to a well structured plan and not straying from it.
