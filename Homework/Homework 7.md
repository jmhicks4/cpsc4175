## Homework 7
### By James Hicks
1. Testing should take place right after you have finished enough code to test. You should make sure that the individual pieces work, so that later down the line if you run into an issue it will be easier to pin point that issue.

2. Verification is checking that the current software is meeting the requirements that the client has given at that current point in the project. The project doesn't have to be done to do a verification of the project it just has to reach a certain goal. The validation is used at the end of the project to determine if the project has all of the requirements that the client wanted.

3. During the proccess of non-execution-based-testing you don't actually execute the code. Instead you read the code and look for any errors you might see as you are reading it. With execution-based-testing is testing if the code has any problems by executing it and if it works supposedly it should be fine.

4. You are determining the quality of the code by going through the engineering process that the team went through and seeing if their methods will create a good product. If the team has followed a good design method the quality of the product should also be good.

5. The implementors could have different ideas of how the code is suppose to work which means that when they test it, if everything runs they will put their stamp of approval on it. You would also have to worry about the implementors being biased towards their own code which could lead to the code not being as good as it could be. You wouldn't want the testers to implement the code because of the exact reason you wouldn't want the implementors to test the code.

6. Execution testing is testing the software by determining if the product work while running. Whereas correctness proofs is determining if the product works by using the mathematical method of proofs. I would lean towards execution testing being the better and more efficient way to test software. This is due to the fact that with large software products it will require a lot of work to provide proofs for all of the bits of software. There will also be more room for error the longer the code is.

7. This article discusses the difficulties that some programmers have with programming something they cannot actively see. Due to the fact that you cannot see the progress of your program like you could if you were drawing a picture, it becomes hard for some programmers to progress with their coding. The article discusses possible solutions that could help solve these problem. Such as Khan Academy where you can see the program you are writing actively updating to the side. Another issues with the current style of programming, is that some developers don't plan before they code. This makes writing large code harder than it should be, because without a laid out plan it becomes much harder to write a coherent code. The article emphasizes that in order to make programming more aproachable to non coding people we will need to make coding less abstract and make it easier to see the process going on.

8. I think that the primary solution to that problem will be offering coding classes to people at a younger age and focusing on teach people to have an overall plan before coding. Another solution will be to expand on tools like Khan academy which make it easier to moniter your program in progress. As to whether there will be a coding apocalypse, I don't think so, sure we will have some major problems with programs due to bad programming practices, but I think that the updates of technology will help make those problems less frequent.