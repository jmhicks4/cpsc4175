## Homework 7
### By James Hicks
1. Testing should take place right after you have finished enough code to test. You should make sure that the individual pieces work, so that later down the line if you run into an issue it will be easier to pin point that issue.

2. Verification is checking that the current software is meeting the requirements that the client has given at that current point in the project. The project doesn't have to be done to do a verification of the project it just has to reach a certain goal. The validation is used at the end of the project to determine if the project has all of the requirements that the client wanted.

3. During the proccess of non-execution-based-testing you don't actually execute the code. Instead you read the code and look for any errors you might see as you are reading it. With execution-based-testing is testing if the code has any problems by executing it and if it works supposedly it should be fine.

4. You are determining the quality of the code by going through the engineering process that the team went through and seeing if their methods will create a good product. If the team has followed a good design method the quality of the product should also be good.

5. The implementors could have different ideas of how the code is suppose to work which means that when they test it, if everything runs they will put their stamp of approval on it. You would also have to worry about the implementors being biased towards their own code which could lead to the code not being as good as it could be. You wouldn't want the testers to implement the code because of the exact reason you wouldn't want the implementors to test the code.

6. Execution testing is testing the software by determining if the product work while running. Whereas correctness proofs is determining if the product works by using the mathematical method of proofs. I would lean towards execution testing being the better and more efficient way to test software. This is due to the fact that with large software products it will require a lot of work to provide proofs for all of the bits of software. There will also be more room for error the longer the code is.

7. This article discusses the difficulties that some programmers have with programming something they cannot actively see. Due to the fact that you cannot see the progress of your program like you could if you were drawing a picture, it becomes hard for some programmers to progress with their coding. The article discusses possible solutions that could help solve these problem. Such as Khan Academy where you can see the program you are writing actively updating to the side. Another issues with the current style of programming, is that some developers don't plan before they code. This makes writing large code harder than it should be, because without a laid out plan it becomes much harder to write a coherent code. The article emphasizes that in order to make programming more aproachable to non coding people we will need to make coding less abstract and make it easier to see the process going on.

8. I think that the primary solution to that problem will be offering coding classes to people at a younger age and focusing on teach people to have an overall plan before coding. Another solution will be to expand on tools like Khan academy which make it easier to moniter your program in progress. As to whether there will be a coding apocalypse, I don't think so, sure we will have some major problems with programs due to bad programming practices, but I think that the updates of technology will help make those problems less frequent.
7. Testing a design is somewhat limiting due to the fact that things can change after the implementation stage that would leave your design test out of date. In order to test the graduation program I would first check to make sure that the classes list were printing the correct data, since if it isn't we won't get accurate results from any of our other methods. Then I would check both of the methods that determine if we have the correct amount of credit hours and the mandatory courses completed. I would check with various scenarios in which it should pass and shouldn't pass. After that I would check the method that would make sure we pass both of those methods. If that method works properly that should be all the testing needed for that part of the project.

8. The answer would be 11 - 10 + 2 = 3. This is due to the fact that there are 11 connecting paths and 10 nodes, which led me to the numbers to input into the cyclomatic complexity equation.

9. One CASE tool i have used before is a tool called Modelio. To be honest I was not a huge fan of using it, while I was able to get the program that I wanted finish running, I believe that I could have finished it a lot quicker just programming it. That might change if I were to practice with the tool more, which for the moment doesn't make much sense since we don't use it in school a lot.

10. The article that we read described the programmers at NASA, how they make and design their code to be as close to perfect as possible. First off, I find it amazing that a group of over 200 people are able to make a program complicated enough to run a shuttle but bug free enough to where it won't crash or cause any life threatening issues to the crew. At first this seemed impossible to me until they describe their work culture. At the NASA programming lab they focus on a culture of sticking to the plan. At first I thought that at such high and prestigious lab that they would focus on getting the best of the best that could introduce programming concepts that would bring their code to levels beyond what was thought possible but they explained the reason why they wouldn't do that. Ambition would lead to programmers trying to improve the code in their own way which would make it near impossible to code a program that would be as bug free as NASA needs it to be. The lack of ambition makes them be able to stick to their original plan, which allows them to create such bug free code. It also explains that they spend quite a bit of the initial creation phase not coding but planning, so that they can have a perfected plan to avoid as many issues as possible. Overall this article showed how NASA is able to make such bug free software by sticking to a well structured plan and not straying from it.
